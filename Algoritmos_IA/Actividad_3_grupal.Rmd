---
title: "Resolución Actividad 3 máster Bioinformática UNIR (2025)"
author: "Laura Yera Fernandez, Edurne García Vidal, Sergio Gil Peña, Ander López Imas"
date: "2025-06-10"
output:
  html_document:
    theme:
      bootswatch: flatly
    toc: TRUE
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Algoritmos e Inteligencia Artificial: Actividad 3 grupal

## Librerías

```{r warning = FALSE, message = FALSE}
rm(list=ls())
library(ggplot2)
library(stats)
library(Rtsne)
library(RDRToolbox)
library(uwot)
library(glmnet)
library(tidyverse)
library(caret)
library(rpart)
library(rpart.plot)
library(rattle)
library(PRROC)
library(gridExtra)
library(grDevices)
library(randomForest)
```

## Lectura y procesamiento de los datos

```{r}
setwd("G:/PERSONAL/Edurne/MasterBioInformatica_UNIR/Asignaturas/1rSemestre_AlgoritmoseInteligenciaArtificial/Actividad3")

genes.raw <- readLines("column_names.txt")

labels.raw <- read.csv('classes.csv', header = FALSE, sep = ";")
colnames(labels.raw) <- c("X","Class")
labels.raw$Class <- as.factor(labels.raw$Class)

data.raw <- read.csv('gene_expression.csv', header = FALSE, sep = ";")
colnames(data.raw) <- genes.raw 
#asumimos que la lista de genes corresponde ordenadamente a las columnas de los datos de la expresión de genes, si no quisieramos relacionarlo deberiamos escribir este código colnames(data.raw) <- paste0("gene_", c(1:500))
rownames(data.raw) <- labels.raw$X
data.raw$Class <- labels.raw$Class
```

## Sanity check data y imputación de datos faltantes

```{r}
anyNA(data.raw) 
#Vemos que no hay datos NA o NaN (Not available o Not a number) en la data, por 
# lo que no nos hará falta imputar.

any(data.raw[ , -ncol(data.raw)] == 0)
zero_counts <- colSums(data.raw[ , -ncol(data.raw)] == 0)
zero_counts

zero_df <- data.frame(
  Variable = names(zero_counts),
  Zeros = as.numeric(zero_counts)
)
ggplot(zero_df, aes(x = Variable, y = Zeros, fill = Variable)) +
  geom_bar(stat = "identity") +
  labs(title = "Cantidad de ceros por columna",
       x = "Variable",
       y = "Número de ceros") +
  theme_minimal() +
  theme(legend.position = "none", 
        axis.text.x = element_blank())  # Oculta la leyenda


# Vemos que hay genes que no tienen ceros, genes que tienen algún cero y genes que 
# tienen muchísimos (>600). Estos últimos casos podrían deberse o a que el gen no se
# expresa o a que hay un error de detección en la técnica. En cualquiera de los casos,
# lo mejor sería simplemente eliminar dichas variables. 

# Estableceremos la norma de eliminar aquellas variables con 75% o más de ceros.
max_zeros <- 0.75*nrow(data.raw)

table(zero_counts > max_zeros)
genes_a_eliminar <- names(zero_counts[zero_counts > max_zeros])

data_filtered <- data.raw %>%
  select(-all_of(genes_a_eliminar))

# También eliminaremos todos aquellos genes que tengan el mismo valor en todas
# las observaciones (sd == 0) ya que no aportan ninguna información.

data_filtered_sd <- sapply(data_filtered[, -ncol(data_filtered)], sd)
anyNA(data_filtered_sd)
table(data_filtered_sd == 0)

# Todos son FALSE (y no hay ningun dato NA), asi que no hay ninguna variable con SD == 0.

# Podemos hacer un diagrama de cajas para variable y vemos los estadísticos y outliers
boxplot(data_filtered[, 1:10], main = "Boxplot de los 10 primeros genes")

# Sólo mirando los primeros genes, ya vemos que se mueven en ordenes distintos, 
# por lo que lo más correcto sería escalar los datos para que puedan ser comparables.
# Lo haremos directamente en los métodos de aprendizaje.
```


## Implementación de métodos no supervisados

### Reducción de dimensionalidad

### Clusterización

## Implementación de métodos supervisados

### Filtrado de variables mediante LASSO/Ridge/Elastic Net

## Preguntas de respuesta corta




